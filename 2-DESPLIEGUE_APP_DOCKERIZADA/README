"2-APPS DOCKERIZADA"
Despliegue Dockerizado de una AplicaciÃ³n Django y React.js
Este proyecto contiene una aplicaciÃ³n web compuesta por un backend desarrollado en Django y un frontend en React.js.
Todo el sistema estÃ¡ configurado para ser desplegado usando Docker Compose, lo que permite simplificar la administraciÃ³n de los servicios.

Despliegue Local.
Requisitos Previos:
1- Clonar el repositorio

git clone https://github.com/ElielBloemer/prueba-tecnica.git
cd prueba-tecnica/

2-Instalar docker y docker-compose
cd /2-DESPLIEGUE_APP_DOCKERIZADA
bash init-docker.sh

Estructura del proyecto:
.
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ Dockerfile        # Dockerfile del backend Django
â”‚   â”œâ”€â”€ entrypoint.sh     # Script de inicializaciÃ³n del backend
â”‚   â”œâ”€â”€ requirements.txt  # Dependencias del backend
â”‚   â””â”€â”€ .env              # Variables de entorno para Django
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ Dockerfile        # Dockerfile del frontend React.js
â”‚   â”œâ”€â”€ package.json      # Dependencias del frontend
â”‚   â””â”€â”€ .env              # Variables de entorno para React.js
â”œâ”€â”€ bd/
â”‚   â”œâ”€â”€ .env.postgres     # Variables de entorno para PostgreSQL
â”‚   â””â”€â”€ data/             # Volumen persistente de la base de datos
â”œâ”€â”€ docker-compose.yml    # ConfiguraciÃ³n de los servicios

Servicios en el Docker Compose
El archivo docker-compose.yml define los siguientes servicios:

Base de Datos (PostgreSQL):
Usa la imagen ligera postgres:12.0-alpine.
Se configura con variables de entorno desde el archivo bd/.env.postgres.
Expone el puerto 5432 para conexiones externas (si fuera necesario).

Backend (Django):
Construido usando un Dockerfile multistage para mantener la imagen ligera.
Expone el puerto 8000.
Configurado para depender del servicio de base de datos.

Frontend (React.js):
Construido con un Dockerfile multistage similar al backend.
Expone el puerto 3000.
Configurado para depender del backend.

ConstrucciÃ³n de las ImÃ¡genes
Se implementaron Dockerfiles multistage para optimizar las imÃ¡genes del backend y frontend.

Redes y Dependencias
Se han configurado redes dedicadas para cada servicio:

net-db: Red compartida entre el backend y la base de datos.
net-app: Red compartida entre el backend y el frontend.
Esto mejora la separaciÃ³n y la seguridad del trÃ¡fico interno.

Construye y levanta los servicios:
docker-compose up --build

los servicios estan corriendo en esos puertos:
Frontend: http://localhost:3000
![alt text](image.png)
Backend: http://localhost:8000

Prueba del Despliegue
Registro de Usuario en el Backend:

Endpoint: /api/users/register
MÃ©todo: POST
Datos requeridos:
    {
    "password": "YOUR-PASSWORD",
    "email": "YOUR-MAIL",
    "username": "YOUR-USER"
    }
Respuesta esperada:
    {
    "success": true,
    "userID": 2,
    "msg": "The user was successfully registered"
    }

Probar conexiÃ³n desde el Frontend:

AsegÃºrate de que API_SERVER=http://back:8000/api/ apunte al backend.
Verifica que las pÃ¡ginas o funcionalidades principales carguen correctamente.    

![alt text](image-1.png)


DESPLIEGUE PARA CLOUD(EKS,GKE)

Requisitos Previos
1-Kubernetes Cluster:
Un cluster Kubernetes funcionando (puede ser en minikube, EKS, GKE, etc.).
2-Kubectl:
Instalar kubectl y autenticarse contra la api k8s.
3-Imagenes:
IMPORTANTE
En la construccion de la imagen del backend(ebloemer/back-craf:v2) se elimino del backend/entrypoint.sh el pedazo de codigo:

if [ "$DATABASE" = "postgres" ]
then
    echo "Waiting for postgres..."

    while ! nc -z $SQL_HOST $SQL_PORT; do
      sleep 0.1
    done

    echo "PostgreSQL started"
fi

y se creo un initContainer en el deployment del backend para ejecutar esa funcion de aguardar 
la inicializacion de la base de datos.

Estructura de los manifiestos
.
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ deployment.yaml       # Deployment del backend
â”‚   â”œâ”€â”€ service.yaml          # Service para el backend
â”‚   â”œâ”€â”€ secret.yaml           # Secret para las credenciales del backend
â”‚   â”œâ”€â”€ hpa.yaml              # HPA para el backend
â”‚   â”œâ”€â”€ networkpolicy.yaml    # NetworkPolicy del backend
â”‚   â””â”€â”€ namespace.yaml        # Namespace para el backend
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ deployment.yaml       # Deployment del frontend
â”‚   â”œâ”€â”€ service.yaml          # Service para el frontend
â”‚   â”œâ”€â”€ configmap.yaml        # ConfigMap para el frontend
â”‚   â”œâ”€â”€ hpa.yaml              # HPA para el frontend
â”‚   â”œâ”€â”€ networkpolicy.yaml    # NetworkPolicy del frontend
â”‚   â””â”€â”€ namespace.yaml        # Namespace para el frontend
â”œâ”€â”€ db/
â”‚   â”œâ”€â”€ deployment.yaml       # Deployment de PostgreSQL
â”‚   â”œâ”€â”€ service.yaml          # Service para PostgreSQL
â”‚   â”œâ”€â”€ secret.yaml           # Secret para PostgreSQL
â”‚   â”œâ”€â”€ networkpolicy.yaml    # NetworkPolicy de PostgreSQL
â”‚   â””â”€â”€ namespace.yaml        # Namespace para PostgreSQL
â”‚   â””â”€â”€ persistentvolumeclaim.yaml # persistentvolumeclaim para PostgreSQL
â”‚   â””â”€â”€ persistentvolume.yaml # persistentvolume para PostgreSQL

Configuraciones Importantes
1-Backend:
 - Utiliza un initContainer para esperar que la base de datos estÃ© disponible antes de iniciar.
 - Utiliza un Secret para las credenciales de la base de datos.
 - Configura sondas (liveness, readiness, startup) para garantizar la salud del servicio.

2-Frontend:
 - El ConfigMap define las variables de entorno necesarias para conectarse al backend.
 - Las sondas aseguran que el servicio estÃ© disponible antes de aceptar trÃ¡fico.

3-Base de Datos:
 - Usa un Secret para almacenar las credenciales.
 - La NetworkPolicy asegura que solo los pods del backend puedan acceder al servicio.
 - PersistentVolumeClaim y persistentVolume para persistencia de datos

4-Autoescalado (HPA):
Tanto el frontend como el backend tienen configurado autoescalado basado en uso de CPU y memoria. 

ConexiÃ³n Entre Componentes
- Base de Datos y Backend:
  El backend se conecta a PostgreSQL utilizando el servicio svc-postgres definido en el namespace base-postgres.
- Backend y Frontend:
  El frontend consume el API del backend usando la URL http://svc-back.backend.svc:8000/api/.
- PolÃ­ticas de Red:
  Las NetworkPolicy limitan el trÃ¡fico solo a las conexiones necesarias entre servicios.

Despliegue de Servicios
cd /2-DESPLIEGUE_APP_DOCKERIZADA/k8s-manifiestos 
kubectl apply -f back.yaml -f front.yaml -f db.yaml 

Si se dispone de un balanceador para poder acceder al servicio del frontend seria se debe crear el ingress 
apuntando al puerto 80 en el svc-front en el namespace frontend, svc-front -n frontend https://DNS-FRONTEND

IMPORTANTE! tambien se debe haber creado el usuario en el backend de la misma forma que se genero anteriormente

Probar el acceso de los servicios via port-forward
BACKEND:
kubectl port-forward svc/svc-back -n backend 8000:8000
Forwarding from 127.0.0.1:8000 -> 8000
Forwarding from [::1]:8000 -> 8000

FRONTEND:
kubectl port-forward svc/svc-front -n frontend 3000:80
Forwarding from 127.0.0.1:3000 -> 3000
Forwarding from [::1]:3000 -> 3000

Autor
Eliel Bloemer
Si tienes dudas, por favor no dudes en contactarme.ğŸ˜Š

